import {BoxMeta, IBox, OnCleanCallback} from './IBox';
import {DataMessage, Message, MessageData} from './Message';
import {IPriorityQueue} from './queue/IPriorityQueue';

/**
 * # Box
 *
 * Box is a basic operational unit.  Every operation on a [Message] is performed by a Box and conversely
 * a Message can be operated only in the Box.  The primary mean of the framework extension is by defining
 * new kinds of boxes.
 *
 * The operation is always considered asynchronous although it may operate synchronously.
 *
 * > ### TODO: (idea1) process: Message[] => Message[] OK
 * >
 * > some operations are naturally on batches -- fetch by Id from DB, API ...
 * > generation is naturally by batches -- query result cursor iteration, FB response, ...
 * > batch can be narrowed to size 1 if needed

 *
 * It receives a batch of Messages and returns (asynchronously) one or more batches of Message.
 *
 * ## Means of operation
 *
 * The Box expects a [Message] to receive with particular fields set.  These are *required* fields and
 * the Box must state them publicly in its metadata.  Similarly, the operation results in some new fields
 * *provided* by the Box that are **appended** to the Message.  The *provided* fields are stated publicly in
 * the metadata as well.
 *
 * ## Cardinality of the result
 *
  * The box can be in one of the following modes:
 *  > ### TODO: (idea1) can be some particular box some time generator and some time a mapper?  OK
 *  > a -- dej mi prvnich 20 commentu vs. dej mi vsechny commenty -- vyhneme se "tupemu" aggregatoru typu "first"
 *  >
 *  > Should the generator/aggregator have different (extended) interface than a mapper?
 *  > Would it be "easy/simple" to extend the framework with new Boxes? Each type will be possibly treated
 *  > differently in the flow/builder.
 *
 *  1. A *mapper* -- it receives a batch of Messages and returns (asynchronously) a batch of Messages of the same
 *  size of the same order. (See TODO above).
 *  2. A *generator* -- a box receives the batch of Messages and creates a sequence of batches of Messages
 *  that can be further directed in the flow.  The Messages can be interspersed with respect to theirs parent in the Batch.
 *
 *  > ### TODO: (idea1) how about push & pull iterations?  Modelled by queue with empty/full events and responses.
 *  > Both regimes are reasonable.
 *  > a. **push** -- e.g. clocks.  Once in a minute, new Message is *pushed* into the flow.  Or subscribed
 *  >  events from DB Query.
 *  > b. **pull** -- e.g. Iterate posts/comments from social network.  Get a batch and *pull* the next once
 *  >   the current has been just finished.  Having it *pushed* can consume my memory. Or a case where *pull*
 *  >   (the query) takes an argument that depends on the previous batch of data (I can't remember any example, though).
 *  >
 *  > Both can be modeled by a queue and generator responding/not responding to events "empty" and "full"
 *  >
 *
 *  > ### TODO: (idea2) generator adds new **dimension** of data, it should be in metadata.
 *  >
 *  > In the beginning the job's data have 0 dimensions. It is only a "point" == a single job description info.
 *  > Further in the flow, a generator produces batches of FB posts, the job's data have single *dimension*
 *  > "posts".  All the Messages in all the batches share the same job describing keys and differ only in fields
 *  > specific to the single post, i.e. populating the "posts" dimension.  It doesn't matter whether the field
 *  > is directly generated by the generator or further derived in the flow from the one directly generated.
 *  > Each subsequent generator adds its dimension to the existing ones.
 *  > If a Box depends on result of other Boxes, the other Boxes must operate on the same dimension, and we should
 *  > be able to check it.
 *
 *  3. An *aggregator* -- a box is consuming batches of Messages grouping by the Message fields but those
 *  of the *dimension* added last.  When it consumes all the dimension for given "group by" fields, it produces
 *  batch of Messages whose dimension has just been consumed.
 *  > ### TODO: (idea2) How do we recognize all the dimension to some "group by" fields is consumed?
 *  >
 *  > in iterative (pull) flow, we recognize it by ordering.  How about push flow?
 *
 *  # Means of extension
 *
 * If I want to have a new Box, I have to
 * 1. Subclass a class Box and set metadata in the constructor?
 * 2. Redefine the method processValue?
 *
 * > ### TODO: (code detail) the settings of the box -- pass it to the constructor?  We should have it in the interface, probably.
 *
 * > ### TODO: (idea2) the Box should provide a flag about the operation. Was it success?  Was it error? Was it not ideal but let's go on?
 *
 * > ### TODO: (code detail) Box life-cycle and onClean actions.
 * >
 * > If Box reads from DB, who maintains connection? Box (and will dispose of it), or the BoxFactory
 * > (somewhere in catalog)?
 *
 *  TODO: (code detail) The Box should produce performance metrics about processing.  In order the Box developer not to care, should it
 *  be in the prototype or in a wrap?
 *
 * TODO: (idea2) logging from the Box.  Should the box log somehow?  Yes, box has internally logger available
 *
 * TODO: (code detail) the Box execution should be membraned (so that it can't alter the global entities)
 *
 * @publicapi
 */
export abstract class Box<T extends MessageData, O extends MessageData, C extends MessageData> implements IBox<T, O> {
	public readonly name: string;
	public readonly meta: BoxMeta;
	public readonly onClean: OnCleanCallback[] = [];
	private readonly queue?: IPriorityQueue<Message>;

	/**
	 *
	 * @param name
	 *  name/identifier of the box
	 * @param meta metadata of the Box.  Should be immutable.  One should be able to instantiate the Box without knowing \
	 * them. The created instance should have the metadata set.
	 *
	 * @param queue TODO: (code detail) What is this?  What is the use for this? What is the Box developer going to do with it?
	 */
	protected constructor(name: string, meta: BoxMeta, queue?: IPriorityQueue<Message>) {
		this.name = name;
		this.meta = meta;
		this.queue = queue;
	}

	/**
	 *  internal_api, the Box developer shouldn't touch this?
	 *  the processing function itself
	 *
	 * @param value A Message (batch of Messages) to act on
	 * @returns If working as a Mapper, the Message(s) are the return value of the Promise.
	 * >   TODO: (idea2) If working as a Generator? It would make a sense to return EventEmitter (message, end, error?)
	 * >  or some other object of that kind.  Let's free the box developer from taking care of "connections" among
	 * >  the boxes.  The flow builder can decide and connect on its own.
	 *
	 * @publicapi
	 */
	public async process(value: T): Promise<O> {
		// TODO: (code detail) here arrives the batch!
		if (this.queue != null) {
			this.queue.setJobFinishedCallback(value.jobId, () => {});
			this.queue.setJobMessageFailedCallback(value.jobId, () => {});
		}
		const result = await this.processValue(value, (chunk: C, priority: number): void => {
			if (this.queue == null) {
				throw new Error(`${this.name} has not defined a queue for generating values.`);
			}
			const messageData: MessageData = {};
			for (const emitKey of this.meta.emits) {
				messageData[emitKey] = chunk[emitKey];
			}
			messageData.jobId = value.jobId;
			// TODO: (code detail) Box shouldn't use Message explicitly its a flow's job to properly format the data
			this.queue.push(new DataMessage(messageData), {
				priority: priority,
				jobId: value.jobId,
			});
		});
		if (this.queue != null) {
			// TODO: (code detail) This should be replaced by the SentinelMessage (formatted by the flow)
			this.queue.pushingFinished(value.jobId);
		}

		return result;
	}

	protected abstract processValue(value: T, emitCallback: (chunk: C, priority: number) => void): Promise<O> | O;
}
