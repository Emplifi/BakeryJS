import {BoxInterface, BoxMeta, OnCleanCallback} from './BoxI';
import {
	DataMessage,
	isData,
	isSentinel,
	Message,
	MessageData,
	SentinelMessage,
} from './Message';
import {PriorityQueueI} from './queue/PriorityQueueI';
import VError from 'verror';
import {ServiceProvider} from './ServiceProvider';
import {asyncTimer} from './stats';

export const noopQueue: PriorityQueueI<any> = {
	push: (msg: any, priority?: number) => undefined,
	length: 0,
	target: '',
};

/**
 * Type of the definig executing code of the Box.
 *
 * The routine that contains the business logic of the Box.  The capability of the function are stated
 * in the metadata, namely *provides*, *emits* and *aggregates*.
 *
 * ### The box does not *aggregate*
 * - When called with `value` only -> it serves as a mapper and *must* return (promise) of MessageData,
 * - when called with both `value` and `emit` -> it serves as a generator and
 *   - each new message emits by calling `emit(data, priority?)`
 *   - when finished with generating, resolves the returned Promise to any value
 *
 * ### The box *aggregates*
 * TODO: (idea1) how is the api for aggregation?
 *
 * @publicapi
 */
export type BoxExecutiveDefinition = (
	serviceProvider: ServiceProvider,
	value: MessageData,
	emit: (chunk: MessageData, priority?: number) => void
) => Promise<MessageData> | MessageData | Promise<any>;

export type BoxFactorySignature = new (
	serviceProvider: ServiceProvider,
	q?: PriorityQueueI<Message>
) => BoxInterface;

/**
 * # Box
 *
 * Box is a basic operational unit.  Every operation on a [Message] is performed by a Box and conversely
 * a Message can be operated only in the Box.  The primary mean of the framework extension is by defining
 * new kinds of boxes.
 *
 * The operation is always considered asynchronous although it may operate synchronously.
 *
 * > ### TODO: (idea1) process: Message[] => Message[] OK
 * >
 * > some operations are naturally on batches -- fetch by Id from DB, API ...
 * > generation is naturally by batches -- query result cursor iteration, FB response, ...
 * > batch can be narrowed to size 1 if needed

 *
 * It receives a batch of Messages and returns (asynchronously) one or more batches of Message.
 *
 * ## Means of operation
 *
 * The Box expects a [Message] to receive with particular fields set.  These are *required* fields and
 * the Box must state them publicly in its metadata.  Similarly, the operation results in some new fields
 * *provided* by the Box that are **appended** to the Message.  The *provided* fields are stated publicly in
 * the metadata as well.
 *
 * ## Cardinality of the result
 *
  * The box can be in one of the following modes:
 *  > ### TODO: can be some particular box some time generator and some time a mapper
 *  > a -- dej mi prvnich 20 commentu vs. dej mi vsechny commenty -- vyhneme se "tupemu" aggregatoru typu "first"
 *  >
 *  > Should the generator/aggregator have different (extended) interface than a mapper?
 *  > Would it be "easy/simple" to extend the framework with new Boxes? Each type will be possibly treated
 *  > differently in the flow/builder.
 *
 *  1. A *mapper* -- it receives a batch of Messages and returns (asynchronously) a batch of Messages of the same
 *  size of the same order. (See TODO above).
 *  2. A *generator* -- a box receives the batch of Messages and creates a sequence of batches of Messages
 *  that can be further directed in the flow.  The Messages can be interspersed with respect to theirs parent in the Batch.
 *
 *  > ### TODO: pull iterations?  Modelled by queue with empty/full events and responses.
 *  > Both regimes are reasonable.
 *  > a. **push** -- e.g. clocks.  Once in a minute, new Message is *pushed* into the flow.  Or subscribed
 *  >  events from DB Query.
 *  > b. **pull** -- e.g. Iterate posts/comments from social network.  Get a batch and *pull* the next once
 *  >   the current has been just finished.  Having it *pushed* can consume my memory. Or a case where *pull*
 *  >   (the query) takes an argument that depends on the previous batch of data (I can't remember any example, though).
 *  >
 *  > Both can be modeled by a queue and generator responding/not responding to events "empty" and "full"
 *  >
 *
 *  > ### TODO: (idea2) generator adds new **dimension** of data, it should be in metadata.
 *  >
 *  > In the beginning the job's data have 0 dimensions. It is only a "point" == a single job description info.
 *  > Further in the flow, a generator produces batches of FB posts, the job's data have single *dimension*
 *  > "posts".  All the Messages in all the batches share the same job describing keys and differ only in fields
 *  > specific to the single post, i.e. populating the "posts" dimension.  It doesn't matter whether the field
 *  > is directly generated by the generator or further derived in the flow from the one directly generated.
 *  > Each subsequent generator adds its dimension to the existing ones.
 *  > If a Box depends on result of other Boxes, the other Boxes must operate on the same dimension, and we should
 *  > be able to check it.
 *
 *  3. An *aggregator* -- a box is consuming batches of Messages grouping by the Message fields but those
 *  of the *dimension* added last.  When it consumes all the dimension for given "group by" fields, it produces
 *  batch of Messages whose dimension has just been consumed.
 *  > ### TODO: (idea2) How do we recognize all the dimension to some "group by" fields is consumed?
 *  >
 *  > in iterative (pull) flow, we recognize it by ordering.  How about push flow?
 *
 *  # Means of extension
 *
 * If I want to have a new Box, I have to
 * 1. (Re-)Define all services (logger, statsd, ...) and pass it to a Program
 * 2. Invoke boxFactory with properly set metadata and
 * 2. the method processValue?
 *
 * > ### TODO: (code detail) the settings of the box -- pass it to the constructor?  We should have it in the interface, probably.
 *
 * > ### the Box should provide a flag about the operation. Was it success?  Was it error? Was it not ideal but let's go on?
 * > * Logging is the bare basic.  Every event from the flow (i.e. BoxThrowsError, process termination, ...) must be logged
 *     into a logger.
 * > * https://www.npmjs.com/package/debug is the second option
 * > * tracing is the most advanced option
 * >
 * > When a box encounters an exception, it
 * > 1. TODO: Logs it into a logger
 * > 2. TODO: Sends the particular message (including the error) into error-drain (so that the user can explore it)
 * > 3. TODO: Stops the flow
 *
 * > ### TODO: (code detail) Box life-cycle and onClean actions.
 * >
 * > If Box reads from DB, who maintains connection? Box (and will dispose of it), or the BoxFactory
 * > (somewhere in catalog)?
 *
 *  TODO: (code detail) The Box should produce performance metrics about processing.  In order the Box developer not to care, should it
 *  be in the prototype or in a wrap?
 *
 * TODO: (code detail) the Box execution should be membraned (so that it can't alter the global entities)
 *
 * @internalapi
 */
abstract class Box implements BoxInterface {
	public readonly name: string;
	public readonly meta: BoxMeta;
	public readonly onClean: OnCleanCallback[] = [];
	private readonly queue: PriorityQueueI<Message>;
	protected readonly serviceProvider: ServiceProvider;

	/**
	 * The Box is a basic unit of execution. It comprises of two levels:
	 * 1. Receiving layer from the flow (the method `process`).  Decomposes the Message, invokes `processValue` and
	 * reacts on its return.
	 *
	 * 2. Executing layer, meant to be overridden in subclasses.
	 *
	 * TODO: (idea2) The 1. layer should be moved into the flow executor.
	 *
	 * @param name
	 *  name/identifier of the box
	 * @param meta metadata of the Box.  Should be immutable.  One should be able to instantiate the Box without knowing \
	 * them. The created instance should have the metadata set.
	 *
	 * @param queue - the output connection of the Box.  Everyone should push to that queue. Mapper, Generator, Aggregator.
	 */
	protected constructor(
		name: string,
		meta: BoxMeta,
		serviceProvider: ServiceProvider,
		queue?: PriorityQueueI<Message>
	) {
		this.name = name;
		this.meta = meta;
		this.serviceProvider = serviceProvider;
		this.queue = queue || (noopQueue as PriorityQueueI<Message>);
	}

	protected neverEmitCallback(): void {
		throw new VError(
			{
				name: 'InconsistentBoxError',
				info: {
					name: this.name,
					meta: this.meta,
				},
			},
			"Box '%s': Can't invoke `emitCallback` unless being a generator/aggregator! Either set metadata filed 'emits' or 'aggregates'.",
			this.name
		);
	}

	private async processMapper(value: DataMessage): Promise<any> {
		try {
			const result = await this.processValue(
				value.getInput(this.meta.requires),
				(chunk: MessageData, priority?: number) =>
					this.neverEmitCallback()
			);
			value.setOutput(this.meta.provides, result);
			this.queue.push(value);
			return;
		} catch (error) {
			const wrap = new VError(
				{
					name: 'BoxInvocationException',
					cause: error,
					info: {
						mode: 'mapper',
						box: {
							name: this.name,
							meta: this.meta,
						},
						value: value.getInput(this.meta.requires),
					},
				},
				"The box '%s' in a %s mode encountered an exception.",
				this.name,
				'mapper'
			);

			throw wrap;
		}
	}

	private async processGenerator(value: DataMessage): Promise<any> {
		try {
			const retValue: any = await this.processValue(
				value.getInput(this.meta.requires),
				(chunk: MessageData, priority?: number) => {
					const msg: Message = value.create();
					msg.setOutput(this.meta.provides, chunk);
					this.queue.push(msg, priority);
				}
			);

			this.queue.push(new SentinelMessage(retValue, value));
			return;
		} catch (error) {
			const wrap = new VError(
				{
					name: 'BoxInvocationException',
					cause: error,
					info: {
						mode: 'generator',
						box: {
							name: this.name,
							meta: this.meta,
						},
						value: value.getInput(this.meta.requires),
					},
				},
				"The box '%s' in a %s mode encountered an exception.",
				this.name,
				'generator'
			);

			throw wrap;
		}
	}

	private async processAggregator(value: Message): Promise<any> {
		throw new VError(
			{
				name: 'NotImplementedError',
				message: "Box '%s': Aggregator has not been implemented yet.",
				info: {
					name: this.name,
					meta: this.meta,
				},
			},
			this.name
		);
	}

	/**
	 *  internal_api, the Box developer shouldn't touch this?
	 *  the processing function itself
	 *
	 * @param value A Message (batch of Messages) to act on
	 * @returns
	 *
	 * @publicapi
	 */
	@asyncTimer
	public async process(value: Message): Promise<any> {
		const isGenerator: boolean = this.meta.emits.length > 0;
		const isAggregator: boolean = this.meta.aggregates;
		const isMapper: boolean = !isAggregator && !isGenerator;

		if (isAggregator) {
			return await this.processAggregator(value);
		} else if (isSentinel(value)) {
			this.queue.push(value);
			return;
		} else if (isData(value)) {
			const dValue: DataMessage = value as DataMessage;
			try {
				if (isMapper) {
					return await this.processMapper(dValue);
				} else if (isGenerator) {
					return await this.processGenerator(dValue);
				}
			} catch (error) {
				this.serviceProvider.get('logger').error(error);
				// TODO: Stop processing (let it bubble up to the queue processor? And the queue then breaks the flow?)
				return null;
			}
		}
	}

	/**
	 * Type of the executing code of the Box's boilerplate.
	 *
	 * The routine that contains the business logic of the Box.  The capability of the function are stated
	 * in the metadata, namely *provides*, *emits* and *aggregates*.
	 *
	 * ### The box does not *aggregate*
	 * - When called with `value` only -> it serves as a mapper and *must* return (promise) of MessageData,
	 * - when called with both `value` and `emit` -> it serves as a generator and
	 *   - each new message emits by calling `emit(data, priority?)`
	 *   - when finished with generating, resolves the returned Promise.  The resolved value is thrown away
	 *     the promise only marks the generation complete.
	 *   - If an error occurres, reject the returned Promise with an Error instance
	 *
	 * ### The box *aggregates*
	 * TODO: (idea1) how is the api for aggregation?
	 *
	 * @internalapi
	 */
	protected abstract processValue(
		msg: MessageData,
		emit: (msg: MessageData, priority?: number) => void
	): Promise<MessageData> | MessageData | Promise<any>;
}

export function boxFactory(
	name: string,
	metadata: BoxMeta,
	processValueDef: BoxExecutiveDefinition
): BoxFactorySignature {
	return class extends Box {
		public constructor(
			serviceProvider: ServiceProvider,
			q?: PriorityQueueI<Message>
		) {
			super(name, metadata, serviceProvider, q);
		}
		protected processValue(
			msg: MessageData,
			emit: (msg: MessageData, priority?: number) => void
		) {
			return processValueDef(this.serviceProvider, msg, emit);
		}
	};
}
