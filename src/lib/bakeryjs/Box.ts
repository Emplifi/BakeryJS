import {BoxMeta, IBox, OnCleanCallback} from './IBox';
import {DataMessage, is_Data, is_Sentinel, Message, MessageData, SentinelMessage} from './Message';
import {IPriorityQueue} from './queue/IPriorityQueue';
import VError = require("verror");

const noop = function() {};

/**
 * # Box
 *
 * Box is a basic operational unit.  Every operation on a [Message] is performed by a Box and conversely
 * a Message can be operated only in the Box.  The primary mean of the framework extension is by defining
 * new kinds of boxes.
 *
 * The operation is always considered asynchronous although it may operate synchronously.
 *
 * > ### TODO: (idea1) process: Message[] => Message[] OK
 * >
 * > some operations are naturally on batches -- fetch by Id from DB, API ...
 * > generation is naturally by batches -- query result cursor iteration, FB response, ...
 * > batch can be narrowed to size 1 if needed

 *
 * It receives a batch of Messages and returns (asynchronously) one or more batches of Message.
 *
 * ## Means of operation
 *
 * The Box expects a [Message] to receive with particular fields set.  These are *required* fields and
 * the Box must state them publicly in its metadata.  Similarly, the operation results in some new fields
 * *provided* by the Box that are **appended** to the Message.  The *provided* fields are stated publicly in
 * the metadata as well.
 *
 * ## Cardinality of the result
 *
  * The box can be in one of the following modes:
 *  > ### TODO: (idea1) can be some particular box some time generator and some time a mapper?  OK
 *  > a -- dej mi prvnich 20 commentu vs. dej mi vsechny commenty -- vyhneme se "tupemu" aggregatoru typu "first"
 *  >
 *  > Should the generator/aggregator have different (extended) interface than a mapper?
 *  > Would it be "easy/simple" to extend the framework with new Boxes? Each type will be possibly treated
 *  > differently in the flow/builder.
 *
 *  1. A *mapper* -- it receives a batch of Messages and returns (asynchronously) a batch of Messages of the same
 *  size of the same order. (See TODO above).
 *  2. A *generator* -- a box receives the batch of Messages and creates a sequence of batches of Messages
 *  that can be further directed in the flow.  The Messages can be interspersed with respect to theirs parent in the Batch.
 *
 *  > ### TODO: (idea1) how about push & pull iterations?  Modelled by queue with empty/full events and responses.
 *  > Both regimes are reasonable.
 *  > a. **push** -- e.g. clocks.  Once in a minute, new Message is *pushed* into the flow.  Or subscribed
 *  >  events from DB Query.
 *  > b. **pull** -- e.g. Iterate posts/comments from social network.  Get a batch and *pull* the next once
 *  >   the current has been just finished.  Having it *pushed* can consume my memory. Or a case where *pull*
 *  >   (the query) takes an argument that depends on the previous batch of data (I can't remember any example, though).
 *  >
 *  > Both can be modeled by a queue and generator responding/not responding to events "empty" and "full"
 *  >
 *
 *  > ### TODO: (idea2) generator adds new **dimension** of data, it should be in metadata.
 *  >
 *  > In the beginning the job's data have 0 dimensions. It is only a "point" == a single job description info.
 *  > Further in the flow, a generator produces batches of FB posts, the job's data have single *dimension*
 *  > "posts".  All the Messages in all the batches share the same job describing keys and differ only in fields
 *  > specific to the single post, i.e. populating the "posts" dimension.  It doesn't matter whether the field
 *  > is directly generated by the generator or further derived in the flow from the one directly generated.
 *  > Each subsequent generator adds its dimension to the existing ones.
 *  > If a Box depends on result of other Boxes, the other Boxes must operate on the same dimension, and we should
 *  > be able to check it.
 *
 *  3. An *aggregator* -- a box is consuming batches of Messages grouping by the Message fields but those
 *  of the *dimension* added last.  When it consumes all the dimension for given "group by" fields, it produces
 *  batch of Messages whose dimension has just been consumed.
 *  > ### TODO: (idea2) How do we recognize all the dimension to some "group by" fields is consumed?
 *  >
 *  > in iterative (pull) flow, we recognize it by ordering.  How about push flow?
 *
 *  # Means of extension
 *
 * If I want to have a new Box, I have to
 * 1. Subclass a class Box and set metadata in the constructor?
 * 2. Redefine the method processValue?
 *
 * > ### TODO: (code detail) the settings of the box -- pass it to the constructor?  We should have it in the interface, probably.
 *
 * > ### TODO: (idea2) the Box should provide a flag about the operation. Was it success?  Was it error? Was it not ideal but let's go on?
 *
 * > ### TODO: (code detail) Box life-cycle and onClean actions.
 * >
 * > If Box reads from DB, who maintains connection? Box (and will dispose of it), or the BoxFactory
 * > (somewhere in catalog)?
 *
 *  TODO: (code detail) The Box should produce performance metrics about processing.  In order the Box developer not to care, should it
 *  be in the prototype or in a wrap?
 *
 * TODO: (idea2) logging from the Box.  Should the box log somehow?  Yes, box has internally logger available
 *
 * TODO: (code detail) the Box execution should be membraned (so that it can't alter the global entities)
 *
 * @publicapi
 */
export abstract class Box implements IBox {
	public readonly name: string;
	public readonly meta: BoxMeta;
	public readonly onClean: OnCleanCallback[] = [];
	private readonly queue: IPriorityQueue<Message>;

	/**
	 * The Box is a basic unit of execution. It comprises of two levels:
	 * 1. Receiving layer from the flow (the method `process`).  Decomposes the Message, invokes `processValue` and
	 * reacts on its return.
	 *
	 * 2. Executing layer, meant to be overridden in subclasses.
	 *
	 * TODO: (idea2) The 1. layer should be moved into the flow executor.
	 *
	 * @param name
	 *  name/identifier of the box
	 * @param meta metadata of the Box.  Should be immutable.  One should be able to instantiate the Box without knowing \
	 * them. The created instance should have the metadata set.
	 *
	 * @param queue - the output connection of the Box.  Everyone should push to that queue. Mapper, Generator, Aggregator.
	 */
	protected constructor(
		name: string,
		meta: BoxMeta,
		queue?: IPriorityQueue<Message>
	) {
		this.name = name;
		this.meta = meta;
		this.queue = queue || {push: noop} as IPriorityQueue<Message>;
	}

	private async processMapper(value: DataMessage): Promise<any> {
		// TODO: (idea1) Handle exceptions!
		const result = await this.processValue(value.getInput(this.meta.requires));
		value.setOutput(this.meta.provides, result);
		this.queue.push(value);
		return;
	}

	private async processGenerator(value: DataMessage): Promise<any> {
		//TODO: (idea1) Handle exceptions!
		const retValue: any = await this.processValue(
			value.getInput(this.meta.requires),
			(chunk: MessageData, priority: number) => {
				const msg: Message = value.create();
				msg.setOutput(this.meta.provides, chunk);
				this.queue.push(msg, priority);
			});

		this.queue.push(new SentinelMessage(retValue, value));
		return;
	}

	private async processAggregator(value: Message): Promise<any> {
		throw new VError({
			name: "NotImplementedError",
			message: "Box '%s': Aggregator has not been implemented yet.",
			info: {
				name: this.name,
				meta: this.meta
			}},
			this.name
		);
	}

	/**
	 *  internal_api, the Box developer shouldn't touch this?
	 *  the processing function itself
	 *
	 * @param value A Message (batch of Messages) to act on
	 * @returns
	 *
	 * @publicapi
	 */
	public async process(value: Message): Promise<any> {
		const isGenerator: boolean = (this.meta.emits.length > 0);
		const isAggregator: boolean = this.meta.aggregates;
		const isMapper: boolean = !isAggregator && !isGenerator;

		if (isAggregator) {
			return await this.processAggregator(value);
		}
		else if (is_Sentinel(value)) {
			this.queue.push(value);
			return;
		}
		else if (is_Data(value)) {
			const dValue: DataMessage = <DataMessage> value;
			if (isMapper) {
				return await this.processMapper(dValue);
			}
			else if (isGenerator) {
				return await this.processGenerator(dValue);
			}
		}


	}

	protected abstract processValue(
		value: MessageData,
		emitCallback?: (chunk: MessageData, priority: number) => void
	): Promise<MessageData> | MessageData;
}
